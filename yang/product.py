
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

class yc_property_1_product__property_1(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-1. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-1'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-1']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_1/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_1/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_1/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_1/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_1/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_1/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_1/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_1/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_2_product__property_2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-2']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_2/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_2/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_2/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_2/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_2/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_2/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_2/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_2/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_3_product__property_3(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-3. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-3'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-3']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_3/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_3/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_3/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_3/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_3/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_3/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_3/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_3/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_4_product__property_4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-4'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-4']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_4/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_4/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_4/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_4/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_4/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_4/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_4/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_4/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_5_product__property_5(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-5. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-5'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-5']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_5/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_5/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_5/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_5/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_5/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_5/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_5/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_5/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_6_product__property_6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-6']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_6/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_6/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_6/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_6/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_6/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_6/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_6/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_6/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_7_product__property_7(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-7. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-7'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-7']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_7/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_7/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_7/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_7/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_7/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_7/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_7/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_7/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_8_product__property_8(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-8. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-8'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-8']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_8/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_8/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_8/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_8/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_8/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_8/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_8/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_8/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class yc_property_9_product__property_9(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /property-9. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__val','__unit',)

  _yang_name = 'property-9'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'property-9']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /property_9/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /property_9/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /property_9/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /property_9/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_val(self):
    """
    Getter method for val, mapped from YANG variable /property_9/val (string)
    """
    return self.__val
      
  def _set_val(self, v, load=False):
    """
    Setter method for val, mapped from YANG variable /property_9/val (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_val is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_val() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """val must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__val = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_val(self):
    self.__val = YANGDynClass(base=unicode, is_leaf=True, yang_name="val", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /property_9/unit (string)
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /property_9/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=unicode, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  val = __builtin__.property(_get_val, _set_val)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = {'name': name, 'type': type, 'val': val, 'unit': unit, }


class product(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module product - based on the path /product. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines product
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__vendor_name','__min_threshhold','__max_threshhold','__property_count','__property_max_count','__property_1','__property_2','__property_3','__property_4','__property_5','__property_6','__property_7','__property_8','__property_9',)

  _yang_name = 'product'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__property_8 = YANGDynClass(base=yc_property_8_product__property_8, is_container='container', yang_name="property-8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__property_9 = YANGDynClass(base=yc_property_9_product__property_9, is_container='container', yang_name="property-9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__property_1 = YANGDynClass(base=yc_property_1_product__property_1, is_container='container', yang_name="property-1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__property_2 = YANGDynClass(base=yc_property_2_product__property_2, is_container='container', yang_name="property-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__property_3 = YANGDynClass(base=yc_property_3_product__property_3, is_container='container', yang_name="property-3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__property_4 = YANGDynClass(base=yc_property_4_product__property_4, is_container='container', yang_name="property-4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__property_5 = YANGDynClass(base=yc_property_5_product__property_5, is_container='container', yang_name="property-5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__property_6 = YANGDynClass(base=yc_property_6_product__property_6, is_container='container', yang_name="property-6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__property_7 = YANGDynClass(base=yc_property_7_product__property_7, is_container='container', yang_name="property-7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    self.__min_threshhold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)
    self.__property_max_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(9), is_leaf=True, yang_name="property-max-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)
    self.__vendor_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    self.__property_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="property-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)
    self.__max_threshhold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_vendor_name(self):
    """
    Getter method for vendor_name, mapped from YANG variable /vendor_name (string)
    """
    return self.__vendor_name
      
  def _set_vendor_name(self, v, load=False):
    """
    Setter method for vendor_name, mapped from YANG variable /vendor_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)""",
        })

    self.__vendor_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_name(self):
    self.__vendor_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='string', is_config=True)


  def _get_min_threshhold(self):
    """
    Getter method for min_threshhold, mapped from YANG variable /min_threshhold (uint32)
    """
    return self.__min_threshhold
      
  def _set_min_threshhold(self, v, load=False):
    """
    Setter method for min_threshhold, mapped from YANG variable /min_threshhold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_threshhold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_threshhold() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_threshhold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)""",
        })

    self.__min_threshhold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_threshhold(self):
    self.__min_threshhold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)


  def _get_max_threshhold(self):
    """
    Getter method for max_threshhold, mapped from YANG variable /max_threshhold (uint32)
    """
    return self.__max_threshhold
      
  def _set_max_threshhold(self, v, load=False):
    """
    Setter method for max_threshhold, mapped from YANG variable /max_threshhold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_threshhold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_threshhold() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_threshhold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)""",
        })

    self.__max_threshhold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_threshhold(self):
    self.__max_threshhold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-threshhold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint32', is_config=True)


  def _get_property_count(self):
    """
    Getter method for property_count, mapped from YANG variable /property_count (uint8)
    """
    return self.__property_count
      
  def _set_property_count(self, v, load=False):
    """
    Setter method for property_count, mapped from YANG variable /property_count (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_count() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="property-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_count must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="property-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)""",
        })

    self.__property_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_count(self):
    self.__property_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="property-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)


  def _get_property_max_count(self):
    """
    Getter method for property_max_count, mapped from YANG variable /property_max_count (uint8)
    """
    return self.__property_max_count
      
  def _set_property_max_count(self, v, load=False):
    """
    Setter method for property_max_count, mapped from YANG variable /property_max_count (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_max_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_max_count() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(9), is_leaf=True, yang_name="property-max-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_max_count must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(9), is_leaf=True, yang_name="property-max-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)""",
        })

    self.__property_max_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_max_count(self):
    self.__property_max_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(9), is_leaf=True, yang_name="property-max-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://dhs.example.com/module', defining_module='product', yang_type='uint8', is_config=True)


  def _get_property_1(self):
    """
    Getter method for property_1, mapped from YANG variable /property_1 (container)
    """
    return self.__property_1
      
  def _set_property_1(self, v, load=False):
    """
    Setter method for property_1, mapped from YANG variable /property_1 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_1() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_1_product__property_1, is_container='container', yang_name="property-1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_1 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_1_product__property_1, is_container='container', yang_name="property-1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_1(self):
    self.__property_1 = YANGDynClass(base=yc_property_1_product__property_1, is_container='container', yang_name="property-1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_2(self):
    """
    Getter method for property_2, mapped from YANG variable /property_2 (container)
    """
    return self.__property_2
      
  def _set_property_2(self, v, load=False):
    """
    Setter method for property_2, mapped from YANG variable /property_2 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_2() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_2_product__property_2, is_container='container', yang_name="property-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_2 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_2_product__property_2, is_container='container', yang_name="property-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_2(self):
    self.__property_2 = YANGDynClass(base=yc_property_2_product__property_2, is_container='container', yang_name="property-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_3(self):
    """
    Getter method for property_3, mapped from YANG variable /property_3 (container)
    """
    return self.__property_3
      
  def _set_property_3(self, v, load=False):
    """
    Setter method for property_3, mapped from YANG variable /property_3 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_3() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_3_product__property_3, is_container='container', yang_name="property-3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_3 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_3_product__property_3, is_container='container', yang_name="property-3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_3(self):
    self.__property_3 = YANGDynClass(base=yc_property_3_product__property_3, is_container='container', yang_name="property-3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_4(self):
    """
    Getter method for property_4, mapped from YANG variable /property_4 (container)
    """
    return self.__property_4
      
  def _set_property_4(self, v, load=False):
    """
    Setter method for property_4, mapped from YANG variable /property_4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_4() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_4_product__property_4, is_container='container', yang_name="property-4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_4_product__property_4, is_container='container', yang_name="property-4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_4(self):
    self.__property_4 = YANGDynClass(base=yc_property_4_product__property_4, is_container='container', yang_name="property-4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_5(self):
    """
    Getter method for property_5, mapped from YANG variable /property_5 (container)
    """
    return self.__property_5
      
  def _set_property_5(self, v, load=False):
    """
    Setter method for property_5, mapped from YANG variable /property_5 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_5() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_5_product__property_5, is_container='container', yang_name="property-5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_5 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_5_product__property_5, is_container='container', yang_name="property-5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_5(self):
    self.__property_5 = YANGDynClass(base=yc_property_5_product__property_5, is_container='container', yang_name="property-5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_6(self):
    """
    Getter method for property_6, mapped from YANG variable /property_6 (container)
    """
    return self.__property_6
      
  def _set_property_6(self, v, load=False):
    """
    Setter method for property_6, mapped from YANG variable /property_6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_6() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_6_product__property_6, is_container='container', yang_name="property-6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_6_product__property_6, is_container='container', yang_name="property-6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_6(self):
    self.__property_6 = YANGDynClass(base=yc_property_6_product__property_6, is_container='container', yang_name="property-6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_7(self):
    """
    Getter method for property_7, mapped from YANG variable /property_7 (container)
    """
    return self.__property_7
      
  def _set_property_7(self, v, load=False):
    """
    Setter method for property_7, mapped from YANG variable /property_7 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_7 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_7() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_7_product__property_7, is_container='container', yang_name="property-7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_7 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_7_product__property_7, is_container='container', yang_name="property-7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_7 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_7(self):
    self.__property_7 = YANGDynClass(base=yc_property_7_product__property_7, is_container='container', yang_name="property-7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_8(self):
    """
    Getter method for property_8, mapped from YANG variable /property_8 (container)
    """
    return self.__property_8
      
  def _set_property_8(self, v, load=False):
    """
    Setter method for property_8, mapped from YANG variable /property_8 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_8 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_8() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_8_product__property_8, is_container='container', yang_name="property-8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_8 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_8_product__property_8, is_container='container', yang_name="property-8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_8 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_8(self):
    self.__property_8 = YANGDynClass(base=yc_property_8_product__property_8, is_container='container', yang_name="property-8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)


  def _get_property_9(self):
    """
    Getter method for property_9, mapped from YANG variable /property_9 (container)
    """
    return self.__property_9
      
  def _set_property_9(self, v, load=False):
    """
    Setter method for property_9, mapped from YANG variable /property_9 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_9 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_9() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_property_9_product__property_9, is_container='container', yang_name="property-9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_9 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_property_9_product__property_9, is_container='container', yang_name="property-9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)""",
        })

    self.__property_9 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_9(self):
    self.__property_9 = YANGDynClass(base=yc_property_9_product__property_9, is_container='container', yang_name="property-9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://dhs.example.com/module', defining_module='product', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  vendor_name = __builtin__.property(_get_vendor_name, _set_vendor_name)
  min_threshhold = __builtin__.property(_get_min_threshhold, _set_min_threshhold)
  max_threshhold = __builtin__.property(_get_max_threshhold, _set_max_threshhold)
  property_count = __builtin__.property(_get_property_count, _set_property_count)
  property_max_count = __builtin__.property(_get_property_max_count, _set_property_max_count)
  property_1 = __builtin__.property(_get_property_1, _set_property_1)
  property_2 = __builtin__.property(_get_property_2, _set_property_2)
  property_3 = __builtin__.property(_get_property_3, _set_property_3)
  property_4 = __builtin__.property(_get_property_4, _set_property_4)
  property_5 = __builtin__.property(_get_property_5, _set_property_5)
  property_6 = __builtin__.property(_get_property_6, _set_property_6)
  property_7 = __builtin__.property(_get_property_7, _set_property_7)
  property_8 = __builtin__.property(_get_property_8, _set_property_8)
  property_9 = __builtin__.property(_get_property_9, _set_property_9)


  _pyangbind_elements = {'name': name, 'vendor_name': vendor_name, 'min_threshhold': min_threshhold, 'max_threshhold': max_threshhold, 'property_count': property_count, 'property_max_count': property_max_count, 'property_1': property_1, 'property_2': property_2, 'property_3': property_3, 'property_4': property_4, 'property_5': property_5, 'property_6': property_6, 'property_7': property_7, 'property_8': property_8, 'property_9': property_9, }


